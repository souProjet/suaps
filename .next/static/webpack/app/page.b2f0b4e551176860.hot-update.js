"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/suaps.ts":
/*!************************!*\
  !*** ./utils/suaps.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   conflitEntreDeux: function() { return /* binding */ conflitEntreDeux; },\n/* harmony export */   extractCreneaux: function() { return /* binding */ extractCreneaux; },\n/* harmony export */   filtrerParActivite: function() { return /* binding */ filtrerParActivite; },\n/* harmony export */   formaterHeure: function() { return /* binding */ formaterHeure; },\n/* harmony export */   formaterJour: function() { return /* binding */ formaterJour; },\n/* harmony export */   genererCombinaisons: function() { return /* binding */ genererCombinaisons; },\n/* harmony export */   getActivitesDisponibles: function() { return /* binding */ getActivitesDisponibles; },\n/* harmony export */   heureToMin: function() { return /* binding */ heureToMin; },\n/* harmony export */   pasDeConflit: function() { return /* binding */ pasDeConflit; },\n/* harmony export */   trouverCombinaisons: function() { return /* binding */ trouverCombinaisons; }\n/* harmony export */ });\n/**\n * Transforme les données de l'API en créneaux formatés\n */ function extractCreneaux(data) {\n    const creneaux = [];\n    for (const act of data){\n        if (!act || !act.nom) continue;\n        const nom = act.nom.toLowerCase();\n        const creneauxList = act.creneaux;\n        if (!creneauxList) continue;\n        for (const c of creneauxList){\n            if (!c.horaireDebut || !c.horaireFin || !c.jour) continue;\n            // Extraction des informations de localisation\n            let localisation = undefined;\n            if (c.localisation) {\n                localisation = {\n                    nom: c.localisation.nom,\n                    adresse: c.localisation.adresse,\n                    ville: c.localisation.ville,\n                    codePostal: c.localisation.codePostal\n                };\n            }\n            creneaux.push({\n                activité: nom,\n                jour: c.jour.charAt(0).toUpperCase() + c.jour.slice(1).toLowerCase(),\n                début: c.horaireDebut,\n                fin: c.horaireFin,\n                localisation\n            });\n        }\n    }\n    return creneaux;\n}\n/**\n * Convertit une heure au format HH:MM en minutes depuis minuit\n */ function heureToMin(heure) {\n    const [heures, minutes] = heure.split(\":\").map(Number);\n    return heures * 60 + minutes;\n}\n/**\n * Vérifie s'il y a conflit entre deux créneaux\n */ function conflitEntreDeux(creneau1, creneau2) {\n    if (creneau1.jour !== creneau2.jour) return false;\n    const d1 = heureToMin(creneau1.début);\n    const f1 = heureToMin(creneau1.fin);\n    const d2 = heureToMin(creneau2.début);\n    const f2 = heureToMin(creneau2.fin);\n    // Conflit si les créneaux se chevauchent\n    return !(f1 <= d2 || f2 <= d1);\n}\n/**\n * Vérifie s'il n'y a pas de conflit dans une combinaison de créneaux\n */ function pasDeConflit(creneaux) {\n    for(let i = 0; i < creneaux.length; i++){\n        for(let j = i + 1; j < creneaux.length; j++){\n            if (conflitEntreDeux(creneaux[i], creneaux[j])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Filtre les créneaux par activité\n */ function filtrerParActivite(creneaux, nomActivite) {\n    return creneaux.filter((c)=>c.activité.toLowerCase().includes(nomActivite.toLowerCase()));\n}\n/**\n * Génère toutes les combinaisons possibles de créneaux\n */ function genererCombinaisons(activitesSelectionnees) {\n    if (activitesSelectionnees.length === 0) return [];\n    const result = [];\n    function backtrack(index, combinaisonActuelle) {\n        if (index === activitesSelectionnees.length) {\n            result.push([\n                ...combinaisonActuelle\n            ]);\n            return;\n        }\n        const activite = activitesSelectionnees[index];\n        for (const creneau of activite.creneaux){\n            combinaisonActuelle.push(creneau);\n            backtrack(index + 1, combinaisonActuelle);\n            combinaisonActuelle.pop();\n        }\n    }\n    backtrack(0, []);\n    return result;\n}\n/**\n * Trouve toutes les combinaisons compatibles\n */ function trouverCombinaisons(activitesSelectionnees) {\n    const toutesCombinaisons = genererCombinaisons(activitesSelectionnees);\n    const compatibles = toutesCombinaisons.filter(pasDeConflit);\n    return {\n        compatibles,\n        totalCombinaisons: toutesCombinaisons.length\n    };\n}\n/**\n * Obtient la liste des activités disponibles avec leurs créneaux\n */ function getActivitesDisponibles(creneaux) {\n    const activitesMap = new Map();\n    // Grouper les créneaux par activité\n    for (const creneau of creneaux){\n        const nom = creneau.activité;\n        if (!activitesMap.has(nom)) {\n            activitesMap.set(nom, []);\n        }\n        activitesMap.get(nom).push(creneau);\n    }\n    // Convertir en array d'options avec noms d'affichage\n    return Array.from(activitesMap.entries()).map((param)=>{\n        let [nom, creneauxActivite] = param;\n        return {\n            nom,\n            displayName: nom.charAt(0).toUpperCase() + nom.slice(1),\n            creneaux: creneauxActivite\n        };\n    }).sort((a, b)=>a.displayName.localeCompare(b.displayName));\n}\n/**\n * Formate une heure pour l'affichage\n */ function formaterHeure(heure) {\n    return heure;\n}\n/**\n * Formate un jour pour l'affichage\n */ function formaterJour(jour) {\n    return jour;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3N1YXBzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Q0FFQyxHQUNNLFNBQVNBLGdCQUFnQkMsSUFBbUI7SUFDakQsTUFBTUMsV0FBc0IsRUFBRTtJQUU5QixLQUFLLE1BQU1DLE9BQU9GLEtBQU07UUFDdEIsSUFBSSxDQUFDRSxPQUFPLENBQUNBLElBQUlDLEdBQUcsRUFBRTtRQUV0QixNQUFNQSxNQUFNRCxJQUFJQyxHQUFHLENBQUNDLFdBQVc7UUFDL0IsTUFBTUMsZUFBZUgsSUFBSUQsUUFBUTtRQUVqQyxJQUFJLENBQUNJLGNBQWM7UUFFbkIsS0FBSyxNQUFNQyxLQUFLRCxhQUFjO1lBQzVCLElBQUksQ0FBQ0MsRUFBRUMsWUFBWSxJQUFJLENBQUNELEVBQUVFLFVBQVUsSUFBSSxDQUFDRixFQUFFRyxJQUFJLEVBQUU7WUFFakQsOENBQThDO1lBQzlDLElBQUlDLGVBQWVDO1lBQ25CLElBQUlMLEVBQUVJLFlBQVksRUFBRTtnQkFDbEJBLGVBQWU7b0JBQ2JQLEtBQUtHLEVBQUVJLFlBQVksQ0FBQ1AsR0FBRztvQkFDdkJTLFNBQVNOLEVBQUVJLFlBQVksQ0FBQ0UsT0FBTztvQkFDL0JDLE9BQU9QLEVBQUVJLFlBQVksQ0FBQ0csS0FBSztvQkFDM0JDLFlBQVlSLEVBQUVJLFlBQVksQ0FBQ0ksVUFBVTtnQkFDdkM7WUFDRjtZQUVBYixTQUFTYyxJQUFJLENBQUM7Z0JBQ1pDLFVBQVViO2dCQUNWTSxNQUFNSCxFQUFFRyxJQUFJLENBQUNRLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUtaLEVBQUVHLElBQUksQ0FBQ1UsS0FBSyxDQUFDLEdBQUdmLFdBQVc7Z0JBQ2xFZ0IsT0FBT2QsRUFBRUMsWUFBWTtnQkFDckJjLEtBQUtmLEVBQUVFLFVBQVU7Z0JBQ2pCRTtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU9UO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNxQixXQUFXQyxLQUFhO0lBQ3RDLE1BQU0sQ0FBQ0MsUUFBUUMsUUFBUSxHQUFHRixNQUFNRyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztJQUMvQyxPQUFPSixTQUFTLEtBQUtDO0FBQ3ZCO0FBRUE7O0NBRUMsR0FDTSxTQUFTSSxpQkFBaUJDLFFBQWlCLEVBQUVDLFFBQWlCO0lBQ25FLElBQUlELFNBQVNyQixJQUFJLEtBQUtzQixTQUFTdEIsSUFBSSxFQUFFLE9BQU87SUFFNUMsTUFBTXVCLEtBQUtWLFdBQVdRLFNBQVNWLEtBQUs7SUFDcEMsTUFBTWEsS0FBS1gsV0FBV1EsU0FBU1QsR0FBRztJQUNsQyxNQUFNYSxLQUFLWixXQUFXUyxTQUFTWCxLQUFLO0lBQ3BDLE1BQU1lLEtBQUtiLFdBQVdTLFNBQVNWLEdBQUc7SUFFbEMseUNBQXlDO0lBQ3pDLE9BQU8sQ0FBRVksQ0FBQUEsTUFBTUMsTUFBTUMsTUFBTUgsRUFBQztBQUM5QjtBQUVBOztDQUVDLEdBQ00sU0FBU0ksYUFBYW5DLFFBQW1CO0lBQzlDLElBQUssSUFBSW9DLElBQUksR0FBR0EsSUFBSXBDLFNBQVNxQyxNQUFNLEVBQUVELElBQUs7UUFDeEMsSUFBSyxJQUFJRSxJQUFJRixJQUFJLEdBQUdFLElBQUl0QyxTQUFTcUMsTUFBTSxFQUFFQyxJQUFLO1lBQzVDLElBQUlWLGlCQUFpQjVCLFFBQVEsQ0FBQ29DLEVBQUUsRUFBRXBDLFFBQVEsQ0FBQ3NDLEVBQUUsR0FBRztnQkFDOUMsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU0MsbUJBQW1CdkMsUUFBbUIsRUFBRXdDLFdBQW1CO0lBQ3pFLE9BQU94QyxTQUFTeUMsTUFBTSxDQUFDcEMsQ0FBQUEsSUFDckJBLEVBQUVVLFFBQVEsQ0FBQ1osV0FBVyxHQUFHdUMsUUFBUSxDQUFDRixZQUFZckMsV0FBVztBQUU3RDtBQUVBOztDQUVDLEdBQ00sU0FBU3dDLG9CQUFvQkMsc0JBQXdDO0lBQzFFLElBQUlBLHVCQUF1QlAsTUFBTSxLQUFLLEdBQUcsT0FBTyxFQUFFO0lBRWxELE1BQU1RLFNBQXNCLEVBQUU7SUFFOUIsU0FBU0MsVUFBVUMsS0FBYSxFQUFFQyxtQkFBOEI7UUFDOUQsSUFBSUQsVUFBVUgsdUJBQXVCUCxNQUFNLEVBQUU7WUFDM0NRLE9BQU8vQixJQUFJLENBQUM7bUJBQUlrQzthQUFvQjtZQUNwQztRQUNGO1FBRUEsTUFBTUMsV0FBV0wsc0JBQXNCLENBQUNHLE1BQU07UUFDOUMsS0FBSyxNQUFNRyxXQUFXRCxTQUFTakQsUUFBUSxDQUFFO1lBQ3ZDZ0Qsb0JBQW9CbEMsSUFBSSxDQUFDb0M7WUFDekJKLFVBQVVDLFFBQVEsR0FBR0M7WUFDckJBLG9CQUFvQkcsR0FBRztRQUN6QjtJQUNGO0lBRUFMLFVBQVUsR0FBRyxFQUFFO0lBQ2YsT0FBT0Q7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU08sb0JBQW9CUixzQkFBd0M7SUFJMUUsTUFBTVMscUJBQXFCVixvQkFBb0JDO0lBQy9DLE1BQU1VLGNBQWNELG1CQUFtQlosTUFBTSxDQUFDTjtJQUU5QyxPQUFPO1FBQ0xtQjtRQUNBQyxtQkFBbUJGLG1CQUFtQmhCLE1BQU07SUFDOUM7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU21CLHdCQUF3QnhELFFBQW1CO0lBQ3pELE1BQU15RCxlQUFlLElBQUlDO0lBRXpCLG9DQUFvQztJQUNwQyxLQUFLLE1BQU1SLFdBQVdsRCxTQUFVO1FBQzlCLE1BQU1FLE1BQU1nRCxRQUFRbkMsUUFBUTtRQUM1QixJQUFJLENBQUMwQyxhQUFhRSxHQUFHLENBQUN6RCxNQUFNO1lBQzFCdUQsYUFBYUcsR0FBRyxDQUFDMUQsS0FBSyxFQUFFO1FBQzFCO1FBQ0F1RCxhQUFhSSxHQUFHLENBQUMzRCxLQUFNWSxJQUFJLENBQUNvQztJQUM5QjtJQUVBLHFEQUFxRDtJQUNyRCxPQUFPWSxNQUFNQyxJQUFJLENBQUNOLGFBQWFPLE9BQU8sSUFBSXRDLEdBQUcsQ0FBQztZQUFDLENBQUN4QixLQUFLK0QsaUJBQWlCO2VBQU07WUFDMUUvRDtZQUNBZ0UsYUFBYWhFLElBQUljLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUtmLElBQUlnQixLQUFLLENBQUM7WUFDckRsQixVQUFVaUU7UUFDWjtPQUFJRSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUYsV0FBVyxDQUFDSSxhQUFhLENBQUNELEVBQUVILFdBQVc7QUFDOUQ7QUFFQTs7Q0FFQyxHQUNNLFNBQVNLLGNBQWNqRCxLQUFhO0lBQ3pDLE9BQU9BO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNrRCxhQUFhaEUsSUFBWTtJQUN2QyxPQUFPQTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3N1YXBzLnRzPzZkOWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aXZpdGVBUEksIENyZW5lYXUsIEFjdGl2aXRlT3B0aW9uIH0gZnJvbSAnQC90eXBlcy9zdWFwcyc7XG5cbi8qKlxuICogVHJhbnNmb3JtZSBsZXMgZG9ubsOpZXMgZGUgbCdBUEkgZW4gY3LDqW5lYXV4IGZvcm1hdMOpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdENyZW5lYXV4KGRhdGE6IEFjdGl2aXRlQVBJW10pOiBDcmVuZWF1W10ge1xuICBjb25zdCBjcmVuZWF1eDogQ3JlbmVhdVtdID0gW107XG4gIFxuICBmb3IgKGNvbnN0IGFjdCBvZiBkYXRhKSB7XG4gICAgaWYgKCFhY3QgfHwgIWFjdC5ub20pIGNvbnRpbnVlO1xuICAgIFxuICAgIGNvbnN0IG5vbSA9IGFjdC5ub20udG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjcmVuZWF1eExpc3QgPSBhY3QuY3JlbmVhdXg7XG4gICAgXG4gICAgaWYgKCFjcmVuZWF1eExpc3QpIGNvbnRpbnVlO1xuICAgIFxuICAgIGZvciAoY29uc3QgYyBvZiBjcmVuZWF1eExpc3QpIHtcbiAgICAgIGlmICghYy5ob3JhaXJlRGVidXQgfHwgIWMuaG9yYWlyZUZpbiB8fCAhYy5qb3VyKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdGlvbiBkZXMgaW5mb3JtYXRpb25zIGRlIGxvY2FsaXNhdGlvblxuICAgICAgbGV0IGxvY2FsaXNhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjLmxvY2FsaXNhdGlvbikge1xuICAgICAgICBsb2NhbGlzYXRpb24gPSB7XG4gICAgICAgICAgbm9tOiBjLmxvY2FsaXNhdGlvbi5ub20sXG4gICAgICAgICAgYWRyZXNzZTogYy5sb2NhbGlzYXRpb24uYWRyZXNzZSxcbiAgICAgICAgICB2aWxsZTogYy5sb2NhbGlzYXRpb24udmlsbGUsXG4gICAgICAgICAgY29kZVBvc3RhbDogYy5sb2NhbGlzYXRpb24uY29kZVBvc3RhbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjcmVuZWF1eC5wdXNoKHtcbiAgICAgICAgYWN0aXZpdMOpOiBub20sXG4gICAgICAgIGpvdXI6IGMuam91ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGMuam91ci5zbGljZSgxKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBkw6lidXQ6IGMuaG9yYWlyZURlYnV0LFxuICAgICAgICBmaW46IGMuaG9yYWlyZUZpbixcbiAgICAgICAgbG9jYWxpc2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBjcmVuZWF1eDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0aXQgdW5lIGhldXJlIGF1IGZvcm1hdCBISDpNTSBlbiBtaW51dGVzIGRlcHVpcyBtaW51aXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhldXJlVG9NaW4oaGV1cmU6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IFtoZXVyZXMsIG1pbnV0ZXNdID0gaGV1cmUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIGhldXJlcyAqIDYwICsgbWludXRlcztcbn1cblxuLyoqXG4gKiBWw6lyaWZpZSBzJ2lsIHkgYSBjb25mbGl0IGVudHJlIGRldXggY3LDqW5lYXV4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25mbGl0RW50cmVEZXV4KGNyZW5lYXUxOiBDcmVuZWF1LCBjcmVuZWF1MjogQ3JlbmVhdSk6IGJvb2xlYW4ge1xuICBpZiAoY3JlbmVhdTEuam91ciAhPT0gY3JlbmVhdTIuam91cikgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3QgZDEgPSBoZXVyZVRvTWluKGNyZW5lYXUxLmTDqWJ1dCk7XG4gIGNvbnN0IGYxID0gaGV1cmVUb01pbihjcmVuZWF1MS5maW4pO1xuICBjb25zdCBkMiA9IGhldXJlVG9NaW4oY3JlbmVhdTIuZMOpYnV0KTtcbiAgY29uc3QgZjIgPSBoZXVyZVRvTWluKGNyZW5lYXUyLmZpbik7XG4gIFxuICAvLyBDb25mbGl0IHNpIGxlcyBjcsOpbmVhdXggc2UgY2hldmF1Y2hlbnRcbiAgcmV0dXJuICEoZjEgPD0gZDIgfHwgZjIgPD0gZDEpO1xufVxuXG4vKipcbiAqIFbDqXJpZmllIHMnaWwgbid5IGEgcGFzIGRlIGNvbmZsaXQgZGFucyB1bmUgY29tYmluYWlzb24gZGUgY3LDqW5lYXV4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXNEZUNvbmZsaXQoY3JlbmVhdXg6IENyZW5lYXVbXSk6IGJvb2xlYW4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNyZW5lYXV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY3JlbmVhdXgubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChjb25mbGl0RW50cmVEZXV4KGNyZW5lYXV4W2ldLCBjcmVuZWF1eFtqXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGaWx0cmUgbGVzIGNyw6luZWF1eCBwYXIgYWN0aXZpdMOpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0cmVyUGFyQWN0aXZpdGUoY3JlbmVhdXg6IENyZW5lYXVbXSwgbm9tQWN0aXZpdGU6IHN0cmluZyk6IENyZW5lYXVbXSB7XG4gIHJldHVybiBjcmVuZWF1eC5maWx0ZXIoYyA9PiBcbiAgICBjLmFjdGl2aXTDqS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKG5vbUFjdGl2aXRlLnRvTG93ZXJDYXNlKCkpXG4gICk7XG59XG5cbi8qKlxuICogR8OpbsOocmUgdG91dGVzIGxlcyBjb21iaW5haXNvbnMgcG9zc2libGVzIGRlIGNyw6luZWF1eFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJlckNvbWJpbmFpc29ucyhhY3Rpdml0ZXNTZWxlY3Rpb25uZWVzOiBBY3Rpdml0ZU9wdGlvbltdKTogQ3JlbmVhdVtdW10ge1xuICBpZiAoYWN0aXZpdGVzU2VsZWN0aW9ubmVlcy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgXG4gIGNvbnN0IHJlc3VsdDogQ3JlbmVhdVtdW10gPSBbXTtcbiAgXG4gIGZ1bmN0aW9uIGJhY2t0cmFjayhpbmRleDogbnVtYmVyLCBjb21iaW5haXNvbkFjdHVlbGxlOiBDcmVuZWF1W10pIHtcbiAgICBpZiAoaW5kZXggPT09IGFjdGl2aXRlc1NlbGVjdGlvbm5lZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChbLi4uY29tYmluYWlzb25BY3R1ZWxsZV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBhY3Rpdml0ZSA9IGFjdGl2aXRlc1NlbGVjdGlvbm5lZXNbaW5kZXhdO1xuICAgIGZvciAoY29uc3QgY3JlbmVhdSBvZiBhY3Rpdml0ZS5jcmVuZWF1eCkge1xuICAgICAgY29tYmluYWlzb25BY3R1ZWxsZS5wdXNoKGNyZW5lYXUpO1xuICAgICAgYmFja3RyYWNrKGluZGV4ICsgMSwgY29tYmluYWlzb25BY3R1ZWxsZSk7XG4gICAgICBjb21iaW5haXNvbkFjdHVlbGxlLnBvcCgpO1xuICAgIH1cbiAgfVxuICBcbiAgYmFja3RyYWNrKDAsIFtdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcm91dmUgdG91dGVzIGxlcyBjb21iaW5haXNvbnMgY29tcGF0aWJsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyb3V2ZXJDb21iaW5haXNvbnMoYWN0aXZpdGVzU2VsZWN0aW9ubmVlczogQWN0aXZpdGVPcHRpb25bXSk6IHtcbiAgY29tcGF0aWJsZXM6IENyZW5lYXVbXVtdO1xuICB0b3RhbENvbWJpbmFpc29uczogbnVtYmVyO1xufSB7XG4gIGNvbnN0IHRvdXRlc0NvbWJpbmFpc29ucyA9IGdlbmVyZXJDb21iaW5haXNvbnMoYWN0aXZpdGVzU2VsZWN0aW9ubmVlcyk7XG4gIGNvbnN0IGNvbXBhdGlibGVzID0gdG91dGVzQ29tYmluYWlzb25zLmZpbHRlcihwYXNEZUNvbmZsaXQpO1xuICBcbiAgcmV0dXJuIHtcbiAgICBjb21wYXRpYmxlcyxcbiAgICB0b3RhbENvbWJpbmFpc29uczogdG91dGVzQ29tYmluYWlzb25zLmxlbmd0aFxuICB9O1xufVxuXG4vKipcbiAqIE9idGllbnQgbGEgbGlzdGUgZGVzIGFjdGl2aXTDqXMgZGlzcG9uaWJsZXMgYXZlYyBsZXVycyBjcsOpbmVhdXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGl2aXRlc0Rpc3BvbmlibGVzKGNyZW5lYXV4OiBDcmVuZWF1W10pOiBBY3Rpdml0ZU9wdGlvbltdIHtcbiAgY29uc3QgYWN0aXZpdGVzTWFwID0gbmV3IE1hcDxzdHJpbmcsIENyZW5lYXVbXT4oKTtcbiAgXG4gIC8vIEdyb3VwZXIgbGVzIGNyw6luZWF1eCBwYXIgYWN0aXZpdMOpXG4gIGZvciAoY29uc3QgY3JlbmVhdSBvZiBjcmVuZWF1eCkge1xuICAgIGNvbnN0IG5vbSA9IGNyZW5lYXUuYWN0aXZpdMOpO1xuICAgIGlmICghYWN0aXZpdGVzTWFwLmhhcyhub20pKSB7XG4gICAgICBhY3Rpdml0ZXNNYXAuc2V0KG5vbSwgW10pO1xuICAgIH1cbiAgICBhY3Rpdml0ZXNNYXAuZ2V0KG5vbSkhLnB1c2goY3JlbmVhdSk7XG4gIH1cbiAgXG4gIC8vIENvbnZlcnRpciBlbiBhcnJheSBkJ29wdGlvbnMgYXZlYyBub21zIGQnYWZmaWNoYWdlXG4gIHJldHVybiBBcnJheS5mcm9tKGFjdGl2aXRlc01hcC5lbnRyaWVzKCkpLm1hcCgoW25vbSwgY3JlbmVhdXhBY3Rpdml0ZV0pID0+ICh7XG4gICAgbm9tLFxuICAgIGRpc3BsYXlOYW1lOiBub20uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBub20uc2xpY2UoMSksXG4gICAgY3JlbmVhdXg6IGNyZW5lYXV4QWN0aXZpdGVcbiAgfSkpLnNvcnQoKGEsIGIpID0+IGEuZGlzcGxheU5hbWUubG9jYWxlQ29tcGFyZShiLmRpc3BsYXlOYW1lKSk7XG59XG5cbi8qKlxuICogRm9ybWF0ZSB1bmUgaGV1cmUgcG91ciBsJ2FmZmljaGFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0ZXJIZXVyZShoZXVyZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGhldXJlO1xufVxuXG4vKipcbiAqIEZvcm1hdGUgdW4gam91ciBwb3VyIGwnYWZmaWNoYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRlckpvdXIoam91cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGpvdXI7XG59ICJdLCJuYW1lcyI6WyJleHRyYWN0Q3JlbmVhdXgiLCJkYXRhIiwiY3JlbmVhdXgiLCJhY3QiLCJub20iLCJ0b0xvd2VyQ2FzZSIsImNyZW5lYXV4TGlzdCIsImMiLCJob3JhaXJlRGVidXQiLCJob3JhaXJlRmluIiwiam91ciIsImxvY2FsaXNhdGlvbiIsInVuZGVmaW5lZCIsImFkcmVzc2UiLCJ2aWxsZSIsImNvZGVQb3N0YWwiLCJwdXNoIiwiYWN0aXZpdMOpIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsImTDqWJ1dCIsImZpbiIsImhldXJlVG9NaW4iLCJoZXVyZSIsImhldXJlcyIsIm1pbnV0ZXMiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImNvbmZsaXRFbnRyZURldXgiLCJjcmVuZWF1MSIsImNyZW5lYXUyIiwiZDEiLCJmMSIsImQyIiwiZjIiLCJwYXNEZUNvbmZsaXQiLCJpIiwibGVuZ3RoIiwiaiIsImZpbHRyZXJQYXJBY3Rpdml0ZSIsIm5vbUFjdGl2aXRlIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJnZW5lcmVyQ29tYmluYWlzb25zIiwiYWN0aXZpdGVzU2VsZWN0aW9ubmVlcyIsInJlc3VsdCIsImJhY2t0cmFjayIsImluZGV4IiwiY29tYmluYWlzb25BY3R1ZWxsZSIsImFjdGl2aXRlIiwiY3JlbmVhdSIsInBvcCIsInRyb3V2ZXJDb21iaW5haXNvbnMiLCJ0b3V0ZXNDb21iaW5haXNvbnMiLCJjb21wYXRpYmxlcyIsInRvdGFsQ29tYmluYWlzb25zIiwiZ2V0QWN0aXZpdGVzRGlzcG9uaWJsZXMiLCJhY3Rpdml0ZXNNYXAiLCJNYXAiLCJoYXMiLCJzZXQiLCJnZXQiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY3JlbmVhdXhBY3Rpdml0ZSIsImRpc3BsYXlOYW1lIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImZvcm1hdGVySGV1cmUiLCJmb3JtYXRlckpvdXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/suaps.ts\n"));

/***/ })

});